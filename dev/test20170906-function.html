<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Function</title>
</head>
<body>
<script>
    // function
    // 作用域链和执行环境和变量对象
    // 1.全局环境的变量对象始终存在，变量对象里面包含arguments及全局的变量和函数名
    // 2.在创建函数的时候会创建一个预先包含全局变量对象的作用域链，这个作用域链保存在[[Scope]]里
    // 3.在调用函数的时候，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]中的对象构建起执行环境作用域链，然后创建一个活动对象并推入执行环境作用域链的前端，即此函数的执行环境
    // 4.当函数执行完毕，局部的活动对象就会被摧毁，无论在什么时候在函数中访问一个变量，就会从作用域链中搜索具有相应名字的变量
    // 5.在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域链中
    // 6.无论函数是在哪里调用，也无论函数是如何调用的，其确定的词法作用域永远都是在函数被声明的时候确定下来的

    // this对象
    var name = 'the window';
    var obj = {
        name: 'the obj',
        getNameFunc: function(){
            // return function(){
                return this.name;
            // }
        }
    }

    // obj.getNameFunc();
    // (obj.getNameFunc)();
    // console.log((obj.getNameFunc = obj.getNameFunc)())
    // console.log(obj.getNameFunc()());  // the window，因为匿名函数的执行环境具有全局性，所以this通常指向window

    function foo(){
        // eval(str);
        var b = 7;
        return function(){
            console.log(b);
        }
    }
    // var b = 1
    foo()();
    
</script>
</body>
</html>